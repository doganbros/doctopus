#########################
Manual Setup
#########################

***************************************
Requirements
***************************************

* `Node.js <https://nodejs.org/en/download/>`_ 

* `Yarn <https://yarnpkg.com/en/docs/install>`_ 

* `NestCli <https://docs.nestjs.com/cli/overview>`_ 

* `Postgres <https://www.postgresql.org/>`_ 

***************************************
Getting Started
***************************************

.. code-block:: bash

  git clone https://github.com/doganbros/octopus # Clone Repository
  cd octopus

Install dependencies with

.. code-block:: bash

  yarn install

*********************
Setting up Mattermost
*********************

Please follow the steps below to get a development mattermost server running. The easiest way to use docker.

* Make sure you have docker installed on your computer. If you do not have docker already on your computer, Go to `this link <https://www.docker.com/get-started/>`_, choose your platform and click download. Follow the simple steps to get docker installed on your computer.

* Open your terminal (command prompt or preferably powershell on windows).

* Enter the command ``docker run --name mattermost-preview -d --publish 8065:8065 --add-host dockerhost:127.0.0.1 mattermost/mattermost-preview``. If you want to change the port where mattermost runs by default, replace ``<port>:8065`` by your prefered port while typing the command.

* Wait for some few minutes for the mattermost server to bootup.

* To view the logs enter the command ``docker logs mattermost-preview --follow``.

* You can run multiple instances by just changing the port of your host like above.

* Launch mattermost on your browser by visiting `http://localhost:8065 <http://localhost:8065>`_  or the port that you used above.

* Type in the system administrator's email, username and password. Note that you are supposed to use a username and email different from your account in octopus. This is because octopus will try to create an account for you when you setup everything up.

* You will be asked to create a new team. Create a new team called octopus.

* You will be signed in to the dashboard of mattermost.

* Press the 9 squares menu icon (similiar to grid view icon) on the top left corner. Then click ``System Console``.

* Search for ``Integration Management``.

* Under ``Integration Management``, scroll to the bottom and set ``Enable Personal Access Tokens`` to ``true``.

* Search for ``Bot Accounts``.

* ``Under Bot Accounts``, set ``Enable Bot Account Creation`` to ``true``.

* Now click the hamburger menu on the top left and click ``Switch to octopus``.

* Press the 9 squares menu icon on the top left corner again and then click ``Integrations``.

* Click ``Bot Accounts`` and the ``Add Bot Account`` at the top right of the screen.

* Create a bot with the username octopus-bot. Type in any display name of your choice (Optional). Type in a description (Optional) and select System Admin as the role. Then Click ``Create Bot Account``.

* You will get a setup successful prompt when everything went well. You will also be provided with a token. Please save this token at a secure place because this will be the token octopus will be using to login as the bot.

* Make sure you update all your environment variables for octopus.

* You can find examples at the .env.example file. ``REACT_APP_MM_SERVER_URL``, ``MM_SERVER_URL``, ``MM_BOT_TOKEN``. The ``MM_BOT_TOKEN`` is the token you received while creating a bot account.

* If you already had a valid session at octopus please logout and login again.

****************
Setting up Jitsi
****************

Installing Jitsi with JWT support
=================================

Octopus mmakes use of Jitsi for video streaming and live meeting purposes. It requires a Jitsi installation with JWT token support. You can refer to `this document <https://doganbros.com/index.php/jitsi/jitsi-installation-with-jwt-support-on-ubuntu-18-04-lts/>`_ to install Jitsi.

Installing the mod_octopus.lua Module
=====================================

Once the Jitsi is installed, create a lua file named ``mod_octopus.lua``

.. code-block:: bash

  touch /usr/share/jitsi-meet/prosody-plugins/mod_octopus.lua
  
Populate the lua file with the following

.. code-block:: lua

  local json = require 'util.json'
  local jid = require("util.jid")
  local http = require "net.http";
  local timer = require "util.timer";
  local st = require "util.stanza";
  local have_async, async = pcall(require, "util.async");
  local is_healthcheck_room = module:require "util".is_healthcheck_room;

  local http_headers = {
      ["User-Agent"] = "Prosody ("..prosody.version.."; "..prosody.platform..")",
      ["Content-Type"] = "application/json"
  };
  local http_timeout = 30;
  local storage = module:open_store();
  local octopusBaseUrl = module:get_option_string('octopusAPIBaseUrl');
  
  module:log("info", "loading Octopus module")
  
  function http_post_with_retry(url, retry, reqBody, accessToken)
      local content, code;
      local timeout_occurred;
      local wait, done = async.waiter();
      local function cb(content_, code_, response_, request_)
          if timeout_occurred == nil then
              code = code_;
              if code == 200 or code == 204 or code == 201 then
                  module:log("debug", "External call was successful, content %s", content_);
                  content = content_
              else
                  module:log("warn", "POST REQUEST Error  on public key request: Code %s, Content %s", code_, content_);

                  content = code;
              end
              done();
          else
              module:log("warn", "External call reply delivered after timeout from: %s", url);
          end
      end
  
      http_headers['Authorization'] = accessToken or '';
      local function call_http()
          return http.request(url, {
              headers = http_headers or {},
              method = "POST",
              body = reqBody
          }, cb);
      end

      local request = call_http();
  
      local function cancel()
          -- TODO: This check is racey. Not likely to be a problem, but we should
          --       still stick a mutex on content / code at some point.
          if code == nil then
              timeout_occurred = true;
              module:log("warn", "Timeout %s seconds making the external call to: %s", http_timeout, url);
              -- no longer present in prosody 0.11, so check before calling
              if http.destroy_request ~= nil then
                  http.destroy_request(request);
              end
              if retry == nil then
                  module:log("debug", "External call failed and retry policy is not set");
                  done();
              elseif retry ~= nil and retry < 1 then
                  module:log("debug", "External call failed after retry")
                  done();
              else
                  module:log("debug", "External call failed, retry nr %s", retry)
                  retry = retry - 1;
                  request = call_http()
                  return http_timeout;
              end
          end
      end
      timer.add_task(http_timeout, cancel);
      wait();

      return content;
  end

  function authenticate_octopus()
      local body = {};
        
      local error = nil;
      body["refreshToken"],error =  storage:get("refreshToken");
      local credJson = json.encode(body);
      local response = http_post_with_retry(octopusBaseUrl .. 'auth/client/refresh-token', 1, credJson);
     
      if response == 401 or response == 403 or response == 400 then
        body = {};
        body["apiKey"] = module:get_option_string('octopusApiKey');
        body["apiSecret"] =  module:get_option_string('octopusApiSecret');
        credJson = json.encode(body);

        response = http_post_with_retry(octopusBaseUrl .. 'auth/client/login', 1, credJson);
        if response == 403 then
          module:log("warn", "not authorized");
        elseif response == 400 then
          module:log("warn", "bad request");
        else 
          response = json.decode(response);
          local ok, err = storage:set("accessToken",  response.accessToken);
          ok, err = storage:set("refreshToken",  response.refreshToken);
          if err == nil then
            module:log("info", "new tokens saved successfully using API Key");
          end
        end       
      else 
     
        response = json.decode(response);
        local ok, err = storage:set("accessToken",  response.accessToken);
        ok, err = storage:set("refreshToken",  response.refreshToken);
        if err == nil then
          module:log("info", "new tokens saved successfully using refresh token");
        end
      end 
      return response.accessToken;
  end

  function send_event(meetingTitle, event, userId)
  
      local body = {};
      body['meetingTitle'] = meetingTitle;
      body['event'] = event;
      if userId ~= nil then
          body['userId'] = userId;
      end
      local accessToken =  storage:get("accessToken");
      body = json.encode(body);
      if accessToken ~= nil then
          accessToken = "Bearer " .. accessToken;
      end
      local response = http_post_with_retry(octopusBaseUrl ..'meeting/client/event', 1, body, accessToken);
     
      if response == 401 or response == 403 or response == 400 then
          module:log("info", "[send_event] error exist", event);
          return response
      else 
          module:log("info", "[send_event] successfully sent", event);
      end 
  end

  function occupant_joined(event)
      module:log("info", "********************************************New occupant join******************************************")
  
      local userId = event.occupant:get_presence():get_child('identity');
      if userId ~= nil then
          userId = userId:get_child("user"):get_child_text("id");
          userId = tonumber(userId);
      end
      if event.occupant.role then
          role = event.occupant.role;
          if event.occupant.role ~= 'moderator' then
              local room_name = jid.node(event.room.jid);
              local response = send_event(room_name, 'user_joined', userId);
              if response == 401 then
                  authenticate_octopus();
                  send_event(room_name, 'user_joined', userId);
              end
          end
      end
  end


  function occupant_left(event)
      module:log("info", "********************************************One occupant left******************************************")

      local room_name = jid.node(event.room.jid);
      local userId = event.occupant:get_presence():get_child('identity');
    
       if userId ~= nil then
          userId = userId:get_child("user"):get_child_text("id");
          userId = tonumber(userId);
          local response = send_event(room_name, 'user_left', userId);
          if response == 401 then
              authenticate_octopus();
              send_event(room_name, 'user_left', userId);
          end
      end
  end

  function occupant_pre_joined(event)
      local userId = event.stanza:get_child('identity');
      if userId ~= nil then
          userId = userId:get_child("user"):get_child_text("id");
          userId = tonumber(userId);
      else 
          return nil;
      end
      module:log("info", "********************************************User Pre Join******************************************", userId)

      local body = {};
      body['meetingTitle'] = jid.node(event.room.jid);
      body['userId'] = userId;

      local accessToken =  storage:get("accessToken");
      body = json.encode(body);
      if accessToken ~= nil then
          accessToken = "Bearer " .. accessToken;
      end
      local response = http_post_with_retry(octopusBaseUrl ..'meeting/client/verify', 1, body, accessToken);
      
      if response == 401 then
          module:log("info", "[verify user joining meeting] error exist", response);
          authenticate_octopus();
          return occupant_pre_joined(event)
      else if response == 404  or response == 400 then 
          module:log("info", "[verify user joining meeting] not found");
          local session, stanza = event.origin, event.stanza;

          session.send(
              st.error_reply(
                  stanza, "cancel", "not-allowed", "Room modification disabled for guests"));
          return true;
      else 
          module:log("info", "[verify user joining meeting] successfully sent", response);
      end 
      end
  end

  function room_created(event)
      module:log("info", "********************************************Room is started******************************************")
      local room_name = jid.node(event.room.jid);
      local response = send_event(room_name, 'started');
      if response == 401 then
          authenticate_octopus();
          send_event(room_name, 'started');
      end
  end

  function room_destroyed(event)
      module:log("info", "********************************************Room is Finished******************************************")
      local room_name = jid.node(event.room.jid);
      local response = send_event(room_name, 'ended');
      if response == 401 then
          authenticate_octopus();
          send_event(room_name, 'ended');
      end
    
  end

  module:hook("muc-occupant-pre-join", occupant_pre_joined, 150);
  module:hook("muc-occupant-joined", occupant_joined, 151);
  module:hook("muc-occupant-pre-leave", occupant_left, 152);
  module:hook("muc-room-created", room_created, 153);
  module:hook("muc-room-destroyed", room_destroyed, 154);


Configuring Prosody
===================

Configure ``/etc/prosody/conf.d/your.domain.com.cfg.lua`` by adding octopus to the list of enabled modules of the conference component like below;

.. code-block:: lua

  Component "conference.meet.doganbros.com" "muc"
      restrict_room_creation = true
      storage = "memory"
      modules_enabled = {
          "muc_meeting_id";
          "muc_domain_mapper";
          "polls";
          "octopus";
          "token_verification";
      }
      admins = { "focus@auth.meet.doganbros.com" }
      muc_room_locking = false
      muc_room_default_public_jids = true

***************************************
Setting up the RTMP servers
***************************************

For Octopus, you will need at least one ingress server, and as many additional egress servers as you need for ease of autoscalability. To install NGINX rtmp server, you can follow the guide in `this page <https://docs.nginx.com/nginx/admin-guide/dynamic-modules/rtmp/>`_.

Create Octopus Script
=====================

First you must create a script for RTMP server to communicate with Octopus. Create a file named ``/home/octopus/octopus.sh``. And populate it so;

.. code-block:: bash

  #!/bin/bash

  DATE="$(date)"
  source token.txt
  source octopus.conf
  EVENT_TYPE=$1
  TEMP_ID=$2
  USER_ID=$(cut -d "=" -f2-<<< $TEMP_ID)
  VIDEO_ID=$4
  FILE_ID=$VIDEO_ID
  FILENAME=$6
  FINAL_STATUS_CODE=0
  # AWS credentials
  AWS_ACCESS_KEY=$YOUR_AWS_ACCESS_KEY
  AWS_SECRET_KEY=$YOUR_AWS_SECRET_KEY
  AWS_DEFAULT_REGION=$AWS_DEFAULT_REGION
  S3_BUCKET_NAME=$S3_BUCKET_NAME

  echo "#################################### $DATE --- Reporting Event to Octopus #########################################################" >> /tmp/octopus-rtmp.log
  echo "$DATE --- Event Type: $EVENT_TYPE - User ID: $USER_ID - Video ID: $VIDEO_ID" >> /tmp/octopus-rtmp.log

  upload(){
  # Set credentials for aws cli
  aws configure set aws_access_key_id $AWS_ACCESS_KEY
  aws configure set aws_secret_access_key $AWS_SECRET_KEY
  aws configure set default.region $AWS_DEFAULT_REGION
  # Upload to S3
  aws s3 sync /home/recordings/$FILE_ID s3://$S3_BUCKET_NAME/meeting-recordings/$FILE_ID/
  }

  refresh_octopus(){
    echo "$DATE --- Authentication Token Expired. Attempting to Use Refresh Token." >> /tmp/octopus-rtmp.log
    RESPONSE=$(curl --silent -X POST -H "Content-Type: application/json" -d '{"refreshToken": "'"$REFRESH_TOKEN"'"}' ${OCTOPUS_URL}auth/client/refresh-token)
    STATUS_CODE=$(echo ${RESPONSE} | jq -r '.statusCode')
    if [[ ${STATUS_CODE} == 401 || ${STATUS_CODE} == 403 || ${STATUS_CODE} == 400 ]]
    then
    echo "$DATE --- Refresh Token has expired. Logging in to Octopus..." >> /tmp/octopus-rtmp.log
    RESPONSE=$(curl --silent -X POST -H "Content-Type: application/json" -d '{"apiKey": "'"$API_KEY"'", "apiSecret": "'"$API_SECRET"'"}' ${OCTOPUS_URL}auth/client/login)
    STATUS_CODE=$(echo ${RESPONSE} | jq -r '.statusCode')
    if [ ${STATUS_CODE} == 401 ]; then
     echo "$DATE --- Error While Logging In: Not Authorized" >> /tmp/octopus-rtmp.log
    elif [ ${STATUS_CODE} == 400 ]; then
     echo "$DATE --- Error While Logging In: Bad Request" >> /tmp/octopus-rtmp.log
    else
     echo "$DATE --- Successfully Logged into Octopus. Receiving New Tokens..." >> /tmp/octopus-rtmp.log
     AUTH_TOKEN=$(echo ${RESPONSE} | jq -r '.accessToken')
     REFRESH_TOKEN=$(echo ${RESPONSE} | jq -r '.refreshToken')
     echo "AUTH_TOKEN=$AUTH_TOKEN" > token.txt
     echo "REFRESH_TOKEN=$REFRESH_TOKEN" >> token.txt
    fi
  else
    echo "$DATE --- Refresh Successful. Receiving New Tokens..." >> /tmp/octopus-rtmp.log
    AUTH_TOKEN=$(echo ${RESPONSE} | jq -r '.accessToken')
    REFRESH_TOKEN=$(echo ${RESPONSE} | jq -r '.refreshToken')
    echo "AUTH_TOKEN=$AUTH_TOKEN" > token.txt
    echo "REFRESH_TOKEN=$REFRESH_TOKEN" >> token.txt
  fi
  }
  send_streaming_event(){
   HEADER="Bearer $AUTH_TOKEN"
   echo "Sending Recording Event: slug: $VIDEO_ID and userID is: $USER_ID" >> /tmp/octopus-rtmp.log
   RESPONSE=$(curl --silent -X POST -H "Content-Type: application/json" -H "Authorization: $HEADER" -d '{"event": "'"$EVENT_TYPE"'", "mediaType": "video", "slug": "'"$VIDEO_ID"'", "userId": '$USER_ID'}' ${OCTOPUS_URL}stream/client/event)
   if [[ $RESPONSE != OK ]]; then
   STATUS_CODE=$(echo ${RESPONSE} | jq -r '.statusCode')
   fi
   if [[ ${STATUS_CODE} == 401 || ${STATUS_CODE} == 403 || ${STATUS_CODE} == 400 ]]; then
     echo "$DATE --- Error While Sending Streaming Event Information: $STATUS_CODE" >> /tmp/octopus-rtmp.log
     FINAL_STATUS_CODE=$STATUS_CODE
   fi
  }

  send_recording_event(){
   HEADER="Bearer $AUTH_TOKEN"
   echo "Sending Recording Event: id: $FILE_ID and filename is: $FILENAME" >> /tmp/octopus-rtmp.log
   RESPONSE=$(curl --silent -X POST -H "Content-Type: application/json" -H "Authorization: $HEADER" -d '{"id": "'"$FILE_ID"'", "type": "meeting-recording", "fileName": "'"$FILENAME"'"}' ${OCTOPUS_URL}video/client/feedback)
   if [[ $RESPONSE != OK || $RESPONSE != Created ]]; then
   echo "Recording Event Sent: $RESPONSE" >> /tmp/octopus-rtmp.log
   STATUS_CODE=$(echo ${RESPONSE} | jq -r '.statusCode')
   fi
   if [[ ${STATUS_CODE} == 401 || ${STATUS_CODE} == 403 || ${STATUS_CODE} == 400 ]]; then
     echo "$DATE --- Error While Sending Recording Event Information. STATUS CODE: $STATUS_CODE" >> /tmp/octopus-rtmp.log
     FINAL_STATUS_CODE=$STATUS_CODE
   fi
  }

  echo "$EVENT_TYPE" >> /tmp/octopus-rtmp.log
  if [[ $EVENT_TYPE == record-done ]]; then
   upload
   send_recording_event
   if [[ ${FINAL_STATUS_CODE} == 401 || ${FINAL_STATUS_CODE} == 403 || ${FINAL_STATUS_CODE} == 400 ]]; then
    refresh_octopus
    send_recording_event
    if [[ ${FINAL_STATUS_CODE} == 401 || ${FINAL_STATUS_CODE} == 403 || ${FINAL_STATUS_CODE} == 400 ]]; then
     echo "$DATE --- Error While Sending Event Information. $STATUS_CODE" >> /tmp/octopus-rtmp.log
    else
     echo "$DATE --- Event Sent Successfully" >> /tmp/octopus-rtmp.log
    fi
   fi
  else
   send_streaming_event
   if [[ ${FINAL_STATUS_CODE} == 401 || ${FINAL_STATUS_CODE} == 403 || ${FINAL_STATUS_CODE} == 400 ]]; then
    refresh_octopus
    send_streaming_event
    if [[ ${FINAL_STATUS_CODE} == 401 || ${FINAL_STATUS_CODE} == 403 || ${FINAL_STATUS_CODE} == 400 ]]; then
     echo "$DATE --- Error While Sending Event Information. $STATUS_CODE" >> /tmp/octopus-rtmp.log
    else
     echo "$DATE --- Event Sent Successfully" >> /tmp/octopus-rtmp.log
    fi
   fi
  fi

Define Environment Variables
============================

The script above requires a configuration file. Create a file named ``/home/octopus/octopus.conf`` and populate it;

.. code-block:: bash

  OCTOPUS_URL=$YOUR_END_POINT
  API_KEY=$YOUR_API_KEY
  API_SECRET=$YOUR_API_SECRET

Configure Nginx
===============

Once the script is setup, you must configure streaming applications in ``nginx.conf``. Below is the default example.

.. code-block:: bash

  events {
      worker_connections  1024;
  }

  rtmp {
      server {
          listen 1935;
          application live {
              live on;
              dash on;
              dash_path /tmp/dash;
              dash_fragment 15s;
              exec_play /path/to/octopus.sh play_started $args $pageurl $name;
              exec_play_done /path/to/octopus.sh play_done $args $pageurl $name;
              exec_publish /path/to/octopus.sh publish_started $args $pageurl $name;
              exec_publish_done /path/to/octopus.sh publish_done $args $pageurl $name;
              exec_record_done /path/to/octopus.sh record_done $args $pageurl $name;
          }

          application stream-and-rec {
              live on;
              record all;
              record_path /home/recordings/;
              record_suffix -%d-%b-%y-%T.flv;
              dash on;
              dash_fragment 15s;
              exec_play /path/to/octopus.sh play_started $args $pageurl $name $arg_uid;
              exec_play_done /path/to/octopus.sh play_done $args $pageurl $name $arg_uid;
              exec_publish /path/to/octopus.sh publish_started $args $pageurl $name $arg_uid;
              exec_publish_done /path/to/octopus.sh publish_done $args $pageurl $name $arg_uid;
              exec_record_done /path/to/octopus.sh record_done $args $pageurl $name $arg_uid;
          }

          application encoder{
              live on;
              notify_method get;
              exec ffmpeg -i rtmp://localhost:1935/$app/$name -c:a aac -strict -2 -b:a 256k -c:v libx264 -x264opts bitrate=1024:vbv-maxrate=1024:vbv-bufsize=1024 -rtbufsize 100M -bufsize 1024k -preset veryfast -f flv rtmp://lo>;
          }

          application hls{
              live on;
              hls on;
              hls_path /home/hls;
              hls_nested on;
              hls_fragment 2s;
              exec_play /path/to/octopus.sh play_started $args $pageurl $name $arg_uid;
              exec_play_done /path/to/octopus.sh play_done $args $pageurl $name $arg_uid;
              exec_publish /path/to/octopus.sh publish_started $args $pageurl $name $arg_uid;
              exec_publish_done /path/to/octopus.sh publish_done $args $pageurl $name $arg_uid;
              exec_record_done /path/to/octopus.sh record_done $args $pageurl $name $arg_uid;
          }
      }
  }

  http {
      server {
          listen 80;
          location /tv {
              root /tmp/dash;
          }
      }

      types {
          text/html html;
          application/dash+xml mpd;
      }
  }
  
******************
Setting Up Octopus
******************

Create Postgres Database
========================

Please follow the steps below to get a development Postgres server running. The easiest way to use `docker <https://www.docker.com/>`_. If you have running Postgres database server you can skip these steps and simply create an Octopus database.

* Make sure you have docker installed on your computer. If you do not have docker already on your computer, Go to `this link <https://www.docker.com/get-started/>`_, choose your platform and click download. Follow the simple steps to get docker installed on your computer.

* Open your terminal (command prompt or preferably powershell on windows).

* Enter the command ``docker run --name octopus-dev -e POSTGRES_PASSWORD=$YOUR_POSTGRES_PASSWORD -p 5432:5432 -d postgres``. Postgres docker image will be downloaded and Postgres Docker container with the name octopus-dev will up and serve from port 5432 after this command.

* Run ``docker exec -it octopus-dev psql -U postgres`` to connect your Postgres database.

* Inside the docker container, run ``'CREATE DATABASE octopus'`` to create your Octopus database.

* Run ``\q`` to quit from Psql and Docker container.

Set Environment Variables Into .env File
=======================================

You may configure the environment by making a copy of the boilerplate provided.

.. code-block:: bash

  cp .env.example .env # Then make changes to the boilerplate provided


Seting Web Server and Routing
======================================

If Octopus is installed on your local you will need to add following line to your hosts file. On Unix based systems including MacOS hosts file is ``/etc/hosts`` where as on Windows it is ``C:\windows\system32\drivers\etc\hosts``.

.. code-block:: bash

  127.0.0.1	octopus.localhost
  
***************************************
Running Octopus
***************************************
 
.. code-block:: bash

  yarn server:start:dev # Runs backend side in dev mode
  yarn start:server # Runs backend in production
  yarn start:web # Runs frontend side
