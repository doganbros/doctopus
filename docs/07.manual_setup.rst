#########################
Manual Setup
#########################

***************************************
Requirements
***************************************

* `Node.js <https://nodejs.org/en/download/>`_ 

* `Yarn <https://yarnpkg.com/en/docs/install>`_ 

* `NestCli <https://docs.nestjs.com/cli/overview>`_ 

* `Postgres <https://www.postgresql.org/>`_ 

***************************************
Getting Started
***************************************

.. code-block:: bash

  git clone https://github.com/doganbros/octopus # Clone Repository
  cd octopus

Install dependencies with

.. code-block:: bash

  yarn install

*********************
Setting up Mattermost
*********************

Please follow the steps below to get a development mattermost server running. The easiest way to use docker.

* Make sure you have docker installed on your computer. If you do not have docker already on your computer, Go to `this link <https://www.docker.com/get-started/>`_, choose your platform and click download. Follow the simple steps to get docker installed on your computer.

* Open your terminal (command prompt or preferably powershell on windows).

* Enter the command ``docker run --name mattermost-preview -d --publish 8065:8065 --add-host dockerhost:127.0.0.1 mattermost/mattermost-preview``. If you want to change the port where mattermost runs by default, replace ``<port>:8065`` by your prefered port while typing the command.

* Wait for some few minutes for the mattermost server to bootup.

* To view the logs enter the command ``docker logs mattermost-preview --follow``.

* You can run multiple instances by just changing the port of your host like above.

* Launch mattermost on your browser by visiting `http://localhost:8065 <http://localhost:8065>`_  or the port that you used above.

* Type in the system administrator's email, username and password. Note that you are supposed to use a username and email different from your account in octopus. This is because octopus will try to create an account for you when you setup everything up.

* You will be asked to create a new team. Create a new team called octopus.

* You will be signed in to the dashboard of mattermost.

* Press the 9 squares menu icon (similiar to grid view icon) on the top left corner. Then click ``System Console``.

* Search for ``Integration Management``.

* Under ``Integration Management``, scroll to the bottom and set ``Enable Personal Access Tokens`` to ``true``.

* Search for ``Bot Accounts``.

* ``Under Bot Accounts``, set ``Enable Bot Account Creation`` to ``true``.

* Now click the hamburger menu on the top left and click ``Switch to octopus``.

* Press the 9 squares menu icon on the top left corner again and then click ``Integrations``.

* Click ``Bot Accounts`` and the ``Add Bot Account`` at the top right of the screen.

* Create a bot with the username octopus-bot. Type in any display name of your choice (Optional). Type in a description (Optional) and select System Admin as the role. Then Click ``Create Bot Account``.

* You will get a setup successful prompt when everything went well. You will also be provided with a token. Please save this token at a secure place because this will be the token octopus will be using to login as the bot.

* Make sure you update all your environment variables for octopus.

* You can find examples at the .env.example file. ``REACT_APP_MM_SERVER_URL``, ``MM_SERVER_URL``, ``MM_BOT_TOKEN``. The ``MM_BOT_TOKEN`` is the token you received while creating a bot account.

* If you already had a valid session at octopus please logout and login again.

****************
Setting up Jitsi
****************

Installing Jitsi with JWT support
=================================

Octopus mmakes use of Jitsi for video streaming and live meeting purposes. It requires a Jitsi installation with JWT token support. You can refer to `this document <https://doganbros.com/index.php/jitsi/jitsi-installation-with-jwt-support-on-ubuntu-18-04-lts/>`_ to install Jitsi.

Installing the mod_octopus.lua Module
=====================================

Once the Jitsi is installed, create a lua file named ``mod_octopus.lua``

.. code-block:: bash

  touch /usr/share/jitsi-meet/prosody-plugins/mod_octopus.lua
  
Populate the lua file with the following

.. code-block:: lua

  local json = require 'util.json'
  local jid = require("util.jid")
  local http = require "net.http";
  local timer = require "util.timer";
  local st = require "util.stanza";
  local have_async, async = pcall(require, "util.async");
  local is_healthcheck_room = module:require "util".is_healthcheck_room;

  local http_headers = {
      ["User-Agent"] = "Prosody ("..prosody.version.."; "..prosody.platform..")",
      ["Content-Type"] = "application/json"
  };
  local http_timeout = 30;
  local storage = module:open_store();
  local octopusBaseUrl = module:get_option_string('octopusAPIBaseUrl');
  
  module:log("info", "loading Octopus module")
  
  function http_post_with_retry(url, retry, reqBody, accessToken)
      local content, code;
      local timeout_occurred;
      local wait, done = async.waiter();
      local function cb(content_, code_, response_, request_)
          if timeout_occurred == nil then
              code = code_;
              if code == 200 or code == 204 or code == 201 then
                  module:log("debug", "External call was successful, content %s", content_);
                  content = content_
              else
                  module:log("warn", "POST REQUEST Error  on public key request: Code %s, Content %s", code_, content_);

                  content = code;
              end
              done();
          else
              module:log("warn", "External call reply delivered after timeout from: %s", url);
          end
      end
  
      http_headers['Authorization'] = accessToken or '';
      local function call_http()
          return http.request(url, {
              headers = http_headers or {},
              method = "POST",
              body = reqBody
          }, cb);
      end

      local request = call_http();
  
      local function cancel()
          -- TODO: This check is racey. Not likely to be a problem, but we should
          --       still stick a mutex on content / code at some point.
          if code == nil then
              timeout_occurred = true;
              module:log("warn", "Timeout %s seconds making the external call to: %s", http_timeout, url);
              -- no longer present in prosody 0.11, so check before calling
              if http.destroy_request ~= nil then
                  http.destroy_request(request);
              end
              if retry == nil then
                  module:log("debug", "External call failed and retry policy is not set");
                  done();
              elseif retry ~= nil and retry < 1 then
                  module:log("debug", "External call failed after retry")
                  done();
              else
                  module:log("debug", "External call failed, retry nr %s", retry)
                  retry = retry - 1;
                  request = call_http()
                  return http_timeout;
              end
          end
      end
      timer.add_task(http_timeout, cancel);
      wait();

      return content;
  end

  function authenticate_octopus()
      local body = {};
        
      local error = nil;
      body["refreshToken"],error =  storage:get("refreshToken");
      local credJson = json.encode(body);
      local response = http_post_with_retry(octopusBaseUrl .. 'auth/client/refresh-token', 1, credJson);
     
      if response == 401 or response == 403 or response == 400 then
        body = {};
        body["apiKey"] = module:get_option_string('octopusApiKey');
        body["apiSecret"] =  module:get_option_string('octopusApiSecret');
        credJson = json.encode(body);

        response = http_post_with_retry(octopusBaseUrl .. 'auth/client/login', 1, credJson);
        if response == 403 then
          module:log("warn", "not authorized");
        elseif response == 400 then
          module:log("warn", "bad request");
        else 
          response = json.decode(response);
          local ok, err = storage:set("accessToken",  response.accessToken);
          ok, err = storage:set("refreshToken",  response.refreshToken);
          if err == nil then
            module:log("info", "new tokens saved successfully using API Key");
          end
        end       
      else 
     
        response = json.decode(response);
        local ok, err = storage:set("accessToken",  response.accessToken);
        ok, err = storage:set("refreshToken",  response.refreshToken);
        if err == nil then
          module:log("info", "new tokens saved successfully using refresh token");
        end
      end 
      return response.accessToken;
  end

  function send_event(meetingTitle, event, userId)
  
      local body = {};
      body['meetingTitle'] = meetingTitle;
      body['event'] = event;
      if userId ~= nil then
          body['userId'] = userId;
      end
      local accessToken =  storage:get("accessToken");
      body = json.encode(body);
      if accessToken ~= nil then
          accessToken = "Bearer " .. accessToken;
      end
      local response = http_post_with_retry(octopusBaseUrl ..'meeting/client/event', 1, body, accessToken);
     
      if response == 401 or response == 403 or response == 400 then
          module:log("info", "[send_event] error exist", event);
          return response
      else 
          module:log("info", "[send_event] successfully sent", event);
      end 
  end

  function occupant_joined(event)
      module:log("info", "********************************************New occupant join******************************************")
  
      local userId = event.occupant:get_presence():get_child('identity');
      if userId ~= nil then
          userId = userId:get_child("user"):get_child_text("id");
          userId = tonumber(userId);
      end
      if event.occupant.role then
          role = event.occupant.role;
          if event.occupant.role ~= 'moderator' then
              local room_name = jid.node(event.room.jid);
              local response = send_event(room_name, 'user_joined', userId);
              if response == 401 then
                  authenticate_octopus();
                  send_event(room_name, 'user_joined', userId);
              end
          end
      end
  end


  function occupant_left(event)
      module:log("info", "********************************************One occupant left******************************************")

      local room_name = jid.node(event.room.jid);
      local userId = event.occupant:get_presence():get_child('identity');
    
       if userId ~= nil then
          userId = userId:get_child("user"):get_child_text("id");
          userId = tonumber(userId);
          local response = send_event(room_name, 'user_left', userId);
          if response == 401 then
              authenticate_octopus();
              send_event(room_name, 'user_left', userId);
          end
      end
  end

  function occupant_pre_joined(event)
      local userId = event.stanza:get_child('identity');
      if userId ~= nil then
          userId = userId:get_child("user"):get_child_text("id");
          userId = tonumber(userId);
      else 
          return nil;
      end
      module:log("info", "********************************************User Pre Join******************************************", userId)

      local body = {};
      body['meetingTitle'] = jid.node(event.room.jid);
      body['userId'] = userId;

      local accessToken =  storage:get("accessToken");
      body = json.encode(body);
      if accessToken ~= nil then
          accessToken = "Bearer " .. accessToken;
      end
      local response = http_post_with_retry(octopusBaseUrl ..'meeting/client/verify', 1, body, accessToken);
      
      if response == 401 then
          module:log("info", "[verify user joining meeting] error exist", response);
          authenticate_octopus();
          return occupant_pre_joined(event)
      else if response == 404  or response == 400 then 
          module:log("info", "[verify user joining meeting] not found");
          local session, stanza = event.origin, event.stanza;

          session.send(
              st.error_reply(
                  stanza, "cancel", "not-allowed", "Room modification disabled for guests"));
          return true;
      else 
          module:log("info", "[verify user joining meeting] successfully sent", response);
      end 
      end
  end

  function room_created(event)
      module:log("info", "********************************************Room is started******************************************")
      local room_name = jid.node(event.room.jid);
      local response = send_event(room_name, 'started');
      if response == 401 then
          authenticate_octopus();
          send_event(room_name, 'started');
      end
  end

  function room_destroyed(event)
      module:log("info", "********************************************Room is Finished******************************************")
      local room_name = jid.node(event.room.jid);
      local response = send_event(room_name, 'ended');
      if response == 401 then
          authenticate_octopus();
          send_event(room_name, 'ended');
      end
    
  end

  module:hook("muc-occupant-pre-join", occupant_pre_joined, 150);
  module:hook("muc-occupant-joined", occupant_joined, 151);
  module:hook("muc-occupant-pre-leave", occupant_left, 152);
  module:hook("muc-room-created", room_created, 153);
  module:hook("muc-room-destroyed", room_destroyed, 154);

***************************************
Setting up Octopus
***************************************

Create Postgres Database
========================

Please follow the steps below to get a development Postgres server running. The easiest way to use `docker <https://www.docker.com/>`_. If you have running Postgres database server you can skip these steps and simply create an Octopus database.

* Make sure you have docker installed on your computer. If you do not have docker already on your computer, Go to `this link <https://www.docker.com/get-started/>`_, choose your platform and click download. Follow the simple steps to get docker installed on your computer.

* Open your terminal (command prompt or preferably powershell on windows).

* Enter the command ``docker run --name octopus-dev -e POSTGRES_PASSWORD=$YOUR_POSTGRES_PASSWORD -p 5432:5432 -d postgres``. Postgres docker image will be downloaded and Postgres Docker container with the name octopus-dev will up and serve from port 5432 after this command.

* Run ``docker exec -it octopus-dev psql -U postgres`` to connect your Postgres database.

* Inside the docker container, run ``'CREATE DATABASE octopus'`` to create your Octopus database.

* Run ``\q`` to quit from Psql and Docker container.

Set Environment Variables Into .env File
=======================================

You may configure the environment by making a copy of the boilerplate provided.

.. code-block:: bash

  cp .env.example .env # Then make changes to the boilerplate provided


Seting Web Server and Routing
======================================

If Octopus is installed on your local you will need to add following line to your hosts file. On Unix based systems including MacOS hosts file is ``/etc/hosts`` where as on Windows it is ``C:\windows\system32\drivers\etc\hosts``.

.. code-block:: bash

  127.0.0.1	octopus.localhost
  
***************************************
Running the Project
***************************************
 
.. code-block:: bash

  yarn server:start:dev # Runs backend side in dev mode
  yarn start:server # Runs backend in production
  yarn start:web # Runs frontend side
  

-----------------

This document focuses on style-guide.
It is a kind of coding standards applied to documentation files.
It is not about documentation content.

***************************************
Additional Scripts
***************************************

.. code-block:: bash

  # DATABASE COMMANDS
  
  # run all migrations
  yarn migration:run # Even though nestjs runs this automatically when it boots up.

  # create new migration boilerplate
  yarn migration:create
  
  # LOGS
  
  # show logs in production
  pm2 logs
  
  # TESTING
  
  # unit tests
  yarn server:test

  # e2e tests
  yarn server:test:e2e

  # test coverage
  yarn server:test:cov
  
  # Runs the app server in the development mode.
  yarn server:start:dev
  
  # Runs the app in the development mode.
  # Open http://localhost:3000 to view it in the browser.
  # You will also see any lint errors in the console.
  npm start:web
  
  # Builds the app for production to the build folder. 
  # The build is minified and the filenames include the hashes.
  yarn build
  
  # Remove the single build dependency from your project
  yarn eject
  
.. note::

  **This is a one-way operation. Once you** ``eject`` **you can't go back!**

  If you aren’t satisfied with the build tool and configuration choices, you can ``eject`` at any time. This command will remove the single build dependency from your project.

  Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your   project so you have full control over them. All of the commands except ``eject`` will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own.

  You don’t have to ever use ``eject``. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it.
